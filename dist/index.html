<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app">{{message}}</div>
  <script src="vue.js"></script>
  <script>
    /*
    vue 默认支持响应式数据变化 （双向绑定）
    双向绑定页面需要能够修改（表单等） 数据变化可以影响视图显示
    响应式数据变化 能监控到数据变化 并且更新视图
    vue 并不是mvvm， 只是做视图的（官网，用户界面）
    渐进式： 后续加 组件化 vue-router vuex 
    */
    // console.log(Vue)

    //
    new Vue({
      el: '#app',
      data: {
        message: 'mess',
      }
    })

    // -----------更新流程----------------
    // 一个属性对应一个dep 一个dep对应多个watcher 一个watcher可以对应多个dep

    // 对象更新流程
    vm.message = 'jw'


        // ---------------初渲染------------------

        // 1.默认会调用vue._init方法将用户的参数挂载到$options选项中  vm.$options
        // 2.vue会根据用户的参数进行数据的初始化 props computed watch, 会获取到对象作为数据， 可以通过vm._data访问到用户的数据
        // 3.对数据进行观测 对象 （递归使用的defineProperty） 、 数组  （方法的重写）  劫持到用户的操作，比如用户修改了数据 -》 更新视图  （性能问题）
        // 4.将数据代理到vm对象上 vm.xx => vm._data.xx
        // 5.判断用户是否传入了el 属性 ， 内部会调用$mount方法，此方法也可以用户自己调用
        // 6.对模板的优先级处理 render / template / outerHTML;
        // 7.将模板编译成函数 parserHTML 解析模板-> ast语法树， 解析语法树生成code （codegen） -> render函数
        // 8.通过render方法 生成虚拟dom + 真实的数据 => 真实的dom
        // 9.根据虚拟节点渲染成真实节点
  </script>
  
</body>
</html>